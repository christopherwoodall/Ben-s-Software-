<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Benny Says</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0f172a; color: #e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { position: relative; width: 100%; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; background: #0b2239; }
    .hint { position: absolute; left: 12px; bottom: 12px; font-size: 12px; opacity: .7; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
    <div class="hint">Space = scan (hold 3s = auto-back every 1.5s). Return = select.</div>
  </div>

  <script>
  // ====== Constants ======
  const BACK_HOLD_THRESHOLD = 3000;   // ms to engage back-scan
  const BACK_STEP_INTERVAL  = 1500;   // ms per backward step
  const FORWARD_DEBOUNCE    = 160;    // ms debounce for space release forward step
  const RETURN_DEBOUNCE     = 160;    // ms debounce for return release

  const COLORS = ['#ff5c00', '#5bb0ff', '#39d353', '#a78bfa'];
  const NAMES  = ['Orange','Blue','Green','Purple'];
  const MENU_ITEMS  = ['Easy','Medium','Hard','Exit'];
  const MENU_COLORS = ['#60a5fa', '#34d399', '#f59e0b', '#ef4444'];

  const HILITE = '#ffffff';
  const BG = '#0b2239';
  const FLASH_LIGHTEN = 0.75;

  // ====== Canvas setup ======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = 1;
  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(1, Math.floor(rect.width || window.innerWidth || 800));
    const cssH = Math.max(1, Math.floor(rect.height || window.innerHeight || 600));
    canvas.width = cssW * DPR;
    canvas.height = cssH * DPR;
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ====== Audio ======
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.5; // Medium
  masterGain.connect(audioCtx.destination);

  const TONES = [329.63, 261.63, 392.00, 523.25]; // E4, C4, G4, C5

  function beep(idx, dur) {
    const d = typeof dur === 'number' ? dur : 520;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = TONES[idx % TONES.length];
      gain.gain.value = 0.001;
      osc.connect(gain);
      gain.connect(masterGain);
      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(0.001, now);
      gain.gain.linearRampToValueAtTime(1.0, now + 0.02);
      gain.gain.linearRampToValueAtTime(0.001, now + d/1000);
      osc.start();
      osc.stop(now + d/1000 + 0.02);
    } catch (e) { /* ignore */ }
  }

  // ====== State ======
  const Phase = { TITLE: 'title', SHOWING: 'showing', PLAYER: 'player', GAMEOVER: 'gameover' };
  let phase = Phase.TITLE;
  let sequence = [];
  let playerProgress = 0;
  let round = 0;

  // difficulty
  let colorCount = 4; // set by menu

  // indices
  let highlightIndex = 0; // gameplay scan index 0..colorCount-1
  const titleItems = MENU_ITEMS.slice();
  let titleHighlight = 0; // 0..3

  // timers/flags
  let spaceIsDown = false;
  let spaceDownAt = 0;
  let backScanTimer = null;
  let backScanInterval = null;
  let isBackScanActive = false;
  let lastForwardStepAt = 0;
  let lastReturnAt = 0;

  // visuals
  let flashingIndex = -1;
  let flashUntil = 0;

  // ====== Utilities ======
  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
  function randInt(n) { return Math.floor(Math.random() * n); }
  function speak(text) {
    try {
      const synth = window.speechSynthesis; if (!synth) return;
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;
      synth.cancel(); synth.speak(u);
    } catch (e) { /* ignore */ }
  }

  // ====== Game flow ======
  function startNewGame() {
    sequence = [randInt(colorCount)];
    playerProgress = 0;
    round = 1;
    highlightIndex = 0;
    phase = Phase.SHOWING;
    showSequence();
  }

  async function showSequence() {
    cancelBackScanIfAny();
    phase = Phase.SHOWING;
    speak('Round ' + round);
    await sleep(1800); // wait longer so TTS finishes before sequence
    for (let i = 0; i < sequence.length; i++) {
      const idx = sequence[i];
      flashQuadrant(idx, 480);
      beep(idx, 460);
      await sleep(1060); // slowed by +0.5s (560 -> 1060)
    }
    playerProgress = 0;
    phase = Phase.PLAYER;
  }

  function flashQuadrant(idx, dur) {
    const d = typeof dur === 'number' ? dur : 380;
    flashingIndex = idx;
    flashUntil = performance.now() + d;
  }

  function handlePlayerPick(pick) {
    if (phase !== Phase.PLAYER) return;
    flashQuadrant(pick, 300);
    beep(pick, 550);

    if (pick === sequence[playerProgress]) {
      playerProgress += 1;
      if (playerProgress === sequence.length) {
        round += 1;
        sequence.push(randInt(colorCount));
        phase = Phase.SHOWING;
        setTimeout(showSequence, 320);
      }
    } else {
      phase = Phase.GAMEOVER;
      speakGameOverAndReturnToTitle();
    }
  }

  function speakGameOverAndReturnToTitle() {
    speak('Game over');
    setTimeout(() => {
      phase = Phase.TITLE;
      titleHighlight = 0;
      flashingIndex = -1;
    }, 1500);
  }

  // ====== Input handling ======
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') e.preventDefault();
    if (e.repeat) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();

    if (e.code === 'Space') {
      if (phase === Phase.PLAYER || phase === Phase.TITLE) {
        if (!spaceIsDown) {
          spaceIsDown = true;
          spaceDownAt = performance.now();
          backScanTimer = setTimeout(() => {
            if (spaceIsDown && (performance.now() - spaceDownAt >= BACK_HOLD_THRESHOLD)) {
              isBackScanActive = true;
              backScanInterval = setInterval(() => { stepBackward(); }, BACK_STEP_INTERVAL);
            }
          }, BACK_HOLD_THRESHOLD);
        }
      }
    }
  });

  window.addEventListener('keyup', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      if (!(phase === Phase.PLAYER || phase === Phase.TITLE)) { cancelBackScanIfAny(); return; }
      if (isBackScanActive) {
        cancelBackScanIfAny();
      } else {
        const now = performance.now();
        if (now - lastForwardStepAt >= FORWARD_DEBOUNCE) {
          stepForward();
          lastForwardStepAt = now;
        }
      }
      spaceIsDown = false;
      spaceDownAt = 0;
    }

    if (e.code === 'Enter') {
      const now = performance.now();
      if (now - lastReturnAt < RETURN_DEBOUNCE) return;
      lastReturnAt = now;

      if (phase === Phase.TITLE) {
        const sel = titleItems[titleHighlight];
        if (sel === 'Exit') {
          try { window.close(); } catch (e1) {}
          try { const w = window.open('', '_self'); if (w && w.close) w.close(); } catch (e2) {}
        } else {
          colorCount = sel === 'Easy' ? 2 : (sel === 'Medium' ? 3 : 4);
          startNewGame();
        }
        return;
      }

      if (phase === Phase.SHOWING) return;
      if (phase === Phase.GAMEOVER) return;

      if (phase === Phase.PLAYER) {
        if (highlightIndex >= 0 && highlightIndex < colorCount) handlePlayerPick(highlightIndex);
      }
    }
  });

  function cancelBackScanIfAny() {
    if (backScanTimer) { clearTimeout(backScanTimer); backScanTimer = null; }
    if (backScanInterval) { clearInterval(backScanInterval); backScanInterval = null; }
    isBackScanActive = false;
  }

  function stepForward() {
    if (phase === Phase.PLAYER) {
      highlightIndex = (highlightIndex + 1) % colorCount;
    } else if (phase === Phase.TITLE) {
      titleHighlight = (titleHighlight + 1) % titleItems.length;
      speak(titleItems[titleHighlight]);
    }
  }

  function stepBackward() {
    if (phase === Phase.PLAYER) {
      highlightIndex = (highlightIndex - 1 + colorCount) % colorCount;
    } else if (phase === Phase.TITLE) {
      titleHighlight = (titleHighlight - 1 + titleItems.length) % titleItems.length;
      speak(titleItems[titleHighlight]);
    }
  }

  // ====== Render ======
  function draw() {
    try {
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width || canvas.width / DPR || window.innerWidth || 800));
      const h = Math.max(1, Math.floor(rect.height || canvas.height / DPR || window.innerHeight || 600));

      // Clear
      ctx.fillStyle = BG;
      ctx.fillRect(0, 0, w, h);

      // Title / Score
      ctx.fillStyle = '#e5e7eb';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.font = '700 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';

      if (phase === Phase.TITLE) {
        // Title
        ctx.fillText('Benny Says', w/2, 24);

        // Big menu buttons
        const mx = 20; const mw = w - 40;
        const startY = 90;
        const rows = titleItems.length;
        const btnH = Math.max(72, Math.floor((h - startY - 120) / (rows + 0.3)));
        const gap = Math.max(14, Math.floor(btnH * 0.16));
        for (let i = 0; i < rows; i++) {
          const y = startY + i * (btnH + gap);
          const isSel = (i === titleHighlight);
          const radius = 18;
          ctx.fillStyle = MENU_COLORS[i];
          roundRect(mx, y, mw, btnH, radius);
          ctx.fill();
          if (isSel) {
            ctx.save();
            ctx.lineWidth = 8; ctx.strokeStyle = 'rgba(255,255,255,0.98)';
            ctx.shadowBlur = 22; ctx.shadowColor = 'rgba(255,255,255,0.9)';
            roundRect(mx, y, mw, btnH, radius);
            ctx.stroke();
            ctx.restore();
          }
          ctx.fillStyle = '#0b2239';
          ctx.font = '800 24px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(titleItems[i], mx + mw/2, y + btnH/2);
        }

        ctx.font = '400 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#e5e7eb';
        ctx.fillText('Space = scan, Return = select', w/2, startY + rows*(btnH+gap) + 8);

      } else if (phase === Phase.GAMEOVER) {
        ctx.fillText('Game Over', w/2, 24);
        ctx.font = '400 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.fillText('Returning to menu...', w/2, 60);

      } else {
        ctx.fillText('Round ' + round, w/2, 24);

        // Gameplay tiles (fill screen based on colorCount)
        const pad = 16;
        if (colorCount === 2) {
          const gap = 12; const bx = pad; const bw = (w - pad*2 - gap) / 2;
          const by = 64; const bh = h - by - pad;
          drawTile(0, {x: bx, y: by, w: bw, h: bh});
          drawTile(1, {x: bx + bw + gap, y: by, w: bw, h: bh});
        } else if (colorCount === 3) {
          const gap = 12; const bw = (w - pad*2 - gap*2) / 3;
          const by = 64; const bh = h - by - pad;
          drawTile(0, {x: pad, y: by, w: bw, h: bh});
          drawTile(1, {x: pad + bw + gap, y: by, w: bw, h: bh});
          drawTile(2, {x: pad + (bw + gap) * 2, y: by, w: bw, h: bh});
        } else {
          const gap = 12; const by = 64;
          const bh = (h - by - pad - gap) / 2; const bw = (w - pad*2 - gap) / 2;
          drawTile(0, {x: pad, y: by, w: bw, h: bh});
          drawTile(1, {x: pad + bw + gap, y: by, w: bw, h: bh});
          drawTile(2, {x: pad, y: by + bh + gap, w: bw, h: bh});
          drawTile(3, {x: pad + bw + gap, y: by + bh + gap, w: bw, h: bh});
        }
      }

      if (flashingIndex !== -1 && performance.now() >= flashUntil) {
        flashingIndex = -1;
      }

    } catch (err) {
      // Visible error message on canvas
      ctx.fillStyle = '#111827'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ef4444';
      ctx.font = '600 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.textAlign = 'left'; ctx.textBaseline = 'top';
      ctx.fillText('Render error: ' + (err && err.message ? err.message : String(err)), 12, 12);
    }
    requestAnimationFrame(draw);
  }

  function drawTile(i, q) {
    const now = performance.now();
    const isFlash = (i === flashingIndex) && (now < flashUntil);
    const color = COLORS[i];

    ctx.fillStyle = isFlash ? lighten(color, FLASH_LIGHTEN) : color;
    roundRect(q.x, q.y, q.w, q.h, 28); ctx.fill();

    if (phase === Phase.PLAYER && highlightIndex === i) {
      ctx.save();
      ctx.lineWidth = 12; ctx.strokeStyle = 'rgba(255,255,255,0.98)';
      ctx.shadowBlur = 28; ctx.shadowColor = 'rgba(255,255,255,0.95)';
      roundRect(q.x, q.y, q.w, q.h, 30); ctx.stroke();
      ctx.restore();
    }

    ctx.fillStyle = '#0b2239';
    ctx.font = '800 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(NAMES[i], q.x + q.w/2, q.y + q.h/2);
  }

  function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  function lighten(hex, amt) {
    const a = typeof amt === 'number' ? amt : 0.3;
    const c = hex.replace('#','');
    const r = parseInt(c.slice(0,2),16);
    const g = parseInt(c.slice(2,4),16);
    const b = parseInt(c.slice(4,6),16);
    const lr = Math.min(255, Math.floor(r + (255 - r) * a));
    const lg = Math.min(255, Math.floor(g + (255 - g) * a));
    const lb = Math.min(255, Math.floor(b + (255 - b) * a));
    return '#' + lr.toString(16).padStart(2,'0') + lg.toString(16).padStart(2,'0') + lb.toString(16).padStart(2,'0');
  }

  // Start
  requestAnimationFrame(draw);
  </script>
</body>
</html>
